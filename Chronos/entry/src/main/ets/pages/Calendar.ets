import { TaskItem } from '../components/TaskItem';
import { TaskService } from '../service/TaskService';
import { HolidayService } from '../service/HolidayService';
import { Task } from '../model/Task';
import { Holiday, MxnzpHolidayData } from '../model/Holiday';
import { Utils } from '../common/Utils';
import { Constants } from '../common/Constants';

/**
 * æ—¥å†æ—¥æœŸé¡¹
 */
interface CalendarDay {
  date: Date;
  isCurrentMonth: boolean;
  isToday: boolean;
  isSelected: boolean;
  taskCount: number;
  holiday: Holiday | null;
  calendarInfo: MxnzpHolidayData | null;
}

/**
 * æ—¥å†é¡µé¢ - å›ºå®šæ—¥å†ç½‘æ ¼å¸ƒå±€
 */
@Component
export struct CalendarPage {
  @State selectedDate: Date = new Date();
  @State currentMonth: Date = new Date();
  @State calendarDays: CalendarDay[] = [];
  @State selectedDateTasks: Task[] = [];
  @State allTasks: Task[] = [];
  @State selectedCalendarInfo: MxnzpHolidayData | null = null;
  @State tapActionId: number = 0;
  @State completeActionId: number = 0;
  @State deleteActionId: number = 0;
  @State showDetail: boolean = false;
  @State isLoading: boolean = false;

  private taskService: TaskService = TaskService.getInstance();
  private holidayService: HolidayService = HolidayService.getInstance();
  private today: Date = new Date();

  aboutToAppear() {
    this.loadTasks();
    this.loadCalendarData();
  }

  /**
   * åŠ è½½æ‰€æœ‰ä»»åŠ¡
   */
  async loadTasks(): Promise<void> {
    const tasks = await this.taskService.getAllTasks();
    this.allTasks = [...tasks];
    this.updateSelectedDateTasks();
    this.updateCalendarDays();
  }

  /**
   * åŠ è½½æ—¥å†æ•°æ®ï¼ˆèŠ‚å‡æ—¥å’Œä¸‡å¹´å†ä¿¡æ¯ï¼‰
   */
  async loadCalendarData(): Promise<void> {
    this.isLoading = true;
    const year = this.currentMonth.getFullYear();
    const month = this.currentMonth.getMonth();
    
    // è·å–å½“æœˆæ‰€æœ‰æ—¥æœŸ
    const startDate = new Date(year, month, 1);
    const endDate = new Date(year, month + 1, 0);
    
    console.info(`åŠ è½½${year}å¹´${month + 1}æœˆæ—¥å†æ•°æ®`);
    
    // é€æ—¥åŠ è½½æ•°æ®ï¼ˆä¼šè‡ªåŠ¨ç¼“å­˜ï¼‰
    const currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      await this.holidayService.getHolidayByDate(new Date(currentDate));
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    this.updateCalendarDays();
    this.isLoading = false;
    
    // åŠ è½½é€‰ä¸­æ—¥æœŸçš„è¯¦ç»†ä¿¡æ¯
    await this.loadSelectedDateInfo();
  }

  /**
   * åŠ è½½é€‰ä¸­æ—¥æœŸçš„è¯¦ç»†ä¿¡æ¯
   */
  async loadSelectedDateInfo(): Promise<void> {
    this.selectedCalendarInfo = await this.holidayService.getCalendarInfo(this.selectedDate);
  }

  /**
   * æ›´æ–°æ—¥å†æ—¥æœŸæ•°ç»„
   */
  updateCalendarDays(): void {
    const days: CalendarDay[] = [];
    const year = this.currentMonth.getFullYear();
    const month = this.currentMonth.getMonth();
    
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    
    const firstDayWeek = firstDay.getDay();
    const startDay = firstDayWeek === 0 ? 6 : firstDayWeek - 1;
    
    // ä¸Šä¸ªæœˆçš„æ—¥æœŸ
    const prevMonthLastDay = new Date(year, month, 0).getDate();
    for (let i = startDay - 1; i >= 0; i--) {
      const date = new Date(year, month - 1, prevMonthLastDay - i);
      days.push(this.createCalendarDay(date, false));
    }
    
    // å½“æœˆæ—¥æœŸ
    const daysInMonth = lastDay.getDate();
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      days.push(this.createCalendarDay(date, true));
    }
    
    // ä¸‹ä¸ªæœˆæ—¥æœŸï¼ˆè¡¥é½åˆ°42å¤©ï¼‰
    const remainingDays = 42 - days.length;
    for (let i = 1; i <= remainingDays; i++) {
      const date = new Date(year, month + 1, i);
      days.push(this.createCalendarDay(date, false));
    }
    
    this.calendarDays = [...days];
  }

  /**
   * åˆ›å»ºæ—¥å†æ—¥æœŸé¡¹
   */
  createCalendarDay(date: Date, isCurrentMonth: boolean): CalendarDay {
    const isToday = Utils.isSameDay(date, this.today);
    const isSelected = Utils.isSameDay(date, this.selectedDate);
    const taskCount = this.getTaskCountForDate(date);
    
    // ä»ç¼“å­˜è·å–èŠ‚å‡æ—¥å’Œä¸‡å¹´å†ä¿¡æ¯ï¼ˆä½¿ç”¨å…¬å¼€æ–¹æ³•ï¼‰
    const dateKey = this.getDateKey(date);
    const calendarInfo = this.holidayService.getCalendarFromCache(dateKey);
    const holiday = this.holidayService.getHolidayFromCache(dateKey);
    
    return {
      date: date,
      isCurrentMonth: isCurrentMonth,
      isToday: isToday,
      isSelected: isSelected,
      taskCount: taskCount,
      holiday: holiday,
      calendarInfo: calendarInfo
    };
  }

  /**
   * è·å–æ—¥æœŸé”®
   */
  private getDateKey(date: Date): string {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  /**
   * æ›´æ–°é€‰ä¸­æ—¥æœŸçš„ä»»åŠ¡
   */
  updateSelectedDateTasks(): void {
    const filtered = this.allTasks.filter(task => {
      if (!task.dueDate) return false;
      return Utils.isSameDay(task.dueDate, this.selectedDate);
    });
    this.selectedDateTasks = [...filtered];
  }

  /**
   * é€‰æ‹©æ—¥æœŸ
   */
  async onDateSelect(day: CalendarDay): Promise<void> {
    if (!day.isCurrentMonth) {
      this.currentMonth = new Date(day.date.getFullYear(), day.date.getMonth(), 1);
      await this.loadCalendarData();
    }
    this.selectedDate = day.date;
    this.updateSelectedDateTasks();
    await this.loadSelectedDateInfo();
    this.showDetail = true;
  }

  /**
   * ä¸Šä¸€ä¸ªæœˆ
   */
  async prevMonth(): Promise<void> {
    const newMonth = new Date(this.currentMonth);
    newMonth.setMonth(newMonth.getMonth() - 1);
    this.currentMonth = newMonth;
    await this.loadCalendarData();
  }

  /**
   * ä¸‹ä¸€ä¸ªæœˆ
   */
  async nextMonth(): Promise<void> {
    const newMonth = new Date(this.currentMonth);
    newMonth.setMonth(newMonth.getMonth() + 1);
    this.currentMonth = newMonth;
    await this.loadCalendarData();
  }

  /**
   * è·å–æ—¥æœŸå¯¹åº”çš„ä»»åŠ¡æ•°é‡
   */
  getTaskCountForDate(date: Date): number {
    return this.allTasks.filter(task => {
      if (!task.dueDate) return false;
      return Utils.isSameDay(date, task.dueDate);
    }).length;
  }

  /**
   * 24èŠ‚æ°”åˆ—è¡¨
   */
  private readonly solarTermsList: string[] = [
    'ç«‹æ˜¥', 'é›¨æ°´', 'æƒŠè›°', 'æ˜¥åˆ†', 'æ¸…æ˜', 'è°·é›¨',
    'ç«‹å¤', 'å°æ»¡', 'èŠ’ç§', 'å¤è‡³', 'å°æš‘', 'å¤§æš‘',
    'ç«‹ç§‹', 'å¤„æš‘', 'ç™½éœ²', 'ç§‹åˆ†', 'å¯’éœ²', 'éœœé™',
    'ç«‹å†¬', 'å°é›ª', 'å¤§é›ª', 'å†¬è‡³', 'å°å¯’', 'å¤§å¯’'
  ];

  /**
   * åˆ¤æ–­æ˜¯å¦æ˜¯çœŸæ­£çš„24èŠ‚æ°”ï¼ˆä¸æ˜¯"xxå"ã€"xxå‰"ï¼‰
   */
  isRealSolarTerm(solarTerms: string): boolean {
    if (!solarTerms || solarTerms === 'æ— ') {
      return false;
    }
    // å¦‚æœåŒ…å«"å"æˆ–"å‰"ï¼Œè¯´æ˜ä¸æ˜¯èŠ‚æ°”å½“å¤©
    if (solarTerms.includes('å') || solarTerms.includes('å‰')) {
      return false;
    }
    // æ£€æŸ¥æ˜¯å¦åœ¨24èŠ‚æ°”åˆ—è¡¨ä¸­
    return this.solarTermsList.includes(solarTerms);
  }

  /**
   * è·å–æ—¥å†å•å…ƒæ ¼æ˜¾ç¤ºçš„æ–‡æœ¬
   * ä¼˜å…ˆçº§ï¼šèŠ‚æ—¥ > èŠ‚æ°” > å†œå†
   */
  getCalendarDisplayText(day: CalendarDay): string {
    if (!day.calendarInfo) {
      return '';
    }
    
    // 1. å¦‚æœæ˜¯èŠ‚å‡æ—¥ï¼ˆtype=2ï¼‰ï¼Œæ˜¾ç¤ºèŠ‚æ—¥åç§°
    if (day.holiday && day.holiday.dayType === 2 && day.calendarInfo.typeDes) {
      // æˆªå–èŠ‚æ—¥åç§°ï¼ˆå¯èƒ½æ˜¯"å›½åº†èŠ‚"ã€"æ˜¥èŠ‚"ç­‰ï¼‰
      const festivalName = day.calendarInfo.typeDes;
      if (festivalName !== 'å·¥ä½œæ—¥' && festivalName !== 'ä¼‘æ¯æ—¥') {
        return festivalName;
      }
    }
    
    // 2. å¦‚æœæ˜¯çœŸæ­£çš„24èŠ‚æ°”ï¼Œæ˜¾ç¤ºèŠ‚æ°”
    if (this.isRealSolarTerm(day.calendarInfo.solarTerms)) {
      return day.calendarInfo.solarTerms;
    }
    
    // 3. é»˜è®¤æ˜¾ç¤ºå†œå†æ—¥æœŸ
    return day.calendarInfo.lunarCalendar || '';
  }

  /**
   * å®Œæˆä»»åŠ¡
   */
  async onTaskComplete(task: Task): Promise<void> {
    if (task.status === Constants.TASK_STATUS_COMPLETED) {
      await this.taskService.uncompleteTask(task);
    } else {
      await this.taskService.completeTask(task);
    }
    await this.loadTasks();
  }

  /**
   * åˆ é™¤ä»»åŠ¡
   */
  async onTaskDelete(task: Task): Promise<void> {
    await this.taskService.deleteTask(task);
    await this.loadTasks();
  }

  /**
   * è·³è½¬åˆ°ä»»åŠ¡è¯¦æƒ…
   */
  onTaskTap(task: Task): void {
    console.info('ç‚¹å‡»ä»»åŠ¡:', task.title);
  }

  /**
   * ç›‘å¬çŠ¶æ€å˜åŒ–
   */
  aboutToUpdate() {
    if (this.completeActionId > 0) {
      const task = this.allTasks.find(t => t.id === this.completeActionId);
      if (task) {
        this.onTaskComplete(task);
      }
      this.completeActionId = 0;
    }
    if (this.deleteActionId > 0) {
      const task = this.allTasks.find(t => t.id === this.deleteActionId);
      if (task) {
        this.onTaskDelete(task);
      }
      this.deleteActionId = 0;
    }
    if (this.tapActionId > 0) {
      const task = this.allTasks.find(t => t.id === this.tapActionId);
      if (task) {
        this.onTaskTap(task);
      }
      this.tapActionId = 0;
    }
    this.updateSelectedDateTasks();
  }

  /**
   * æ„å»ºæ—¥å†ç½‘æ ¼
   */
  @Builder
  buildCalendarGrid() {
    Column() {
      // æ˜ŸæœŸæ ‡é¢˜è¡Œ
      Row() {
        ForEach(['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'æ—¥'], (day: string, index: number) => {
          Text(day)
            .fontSize(14)
            .fontColor(index >= 5 ? Constants.COLOR_DANGER : Constants.COLOR_TEXT_SECONDARY)
            .width('14.28%')
            .textAlign(TextAlign.Center)
        })
      }
      .width('100%')
      .height(40)
      .padding({ left: 8, right: 8 })

      // æ—¥æœŸç½‘æ ¼
      Grid() {
        ForEach(this.calendarDays, (day: CalendarDay) => {
          GridItem() {
            this.buildCalendarDay(day)
          }
        })
      }
      .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')
      .rowsTemplate('1fr 1fr 1fr 1fr 1fr 1fr')
      .width('100%')
      .height(360)
      .padding({ left: 8, right: 8, top: 8, bottom: 8 })
    }
    .width('100%')
  }

  /**
   * æ„å»ºå•ä¸ªæ—¥æœŸå•å…ƒæ ¼
   */
  @Builder
  buildCalendarDay(day: CalendarDay) {
    Column() {
      // æ—¥æœŸæ•°å­—
      Text(`${day.date.getDate()}`)
        .fontSize(16)
        .fontWeight(day.isToday || day.isSelected ? FontWeight.Bold : FontWeight.Normal)
        .fontColor(this.getDateTextColor(day))
        .margin({ bottom: 2 })

      // å†œå†æ—¥æœŸã€èŠ‚æ°”æˆ–èŠ‚æ—¥
      if (day.isCurrentMonth && day.calendarInfo) {
        Text(this.getCalendarDisplayText(day))
          .fontSize(9)
          .fontColor(this.getLunarTextColor(day))
          .maxLines(1)
          .textOverflow({ overflow: TextOverflow.Clip })
      }

      // ä»»åŠ¡/èŠ‚å‡æ—¥æ ‡è®°
      Row() {
        if (day.taskCount > 0) {
          Text('â—')
            .fontSize(6)
            .fontColor(Constants.COLOR_PRIMARY)
        }
        if (day.holiday && (day.holiday.dayType === 1 || day.holiday.dayType === 2)) {
          Text(day.holiday.dayType === 2 ? 'ä¼‘' : 'â—')
            .fontSize(day.holiday.dayType === 2 ? 8 : 6)
            .fontColor(Constants.COLOR_DANGER)
            .margin({ left: day.taskCount > 0 ? 2 : 0 })
        }
      }
      .justifyContent(FlexAlign.Center)
      .height(10)
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .backgroundColor(day.isSelected ? Constants.COLOR_PRIMARY_LIGHT : (day.isToday ? '#FFF0E8' : 'transparent'))
    .borderRadius(8)
    .onClick(() => {
      this.onDateSelect(day);
    })
  }

  /**
   * è·å–å†œå†æ–‡å­—é¢œè‰²
   */
  getLunarTextColor(day: CalendarDay): string {
    if (!day.isCurrentMonth) {
      return Constants.COLOR_TEXT_TERTIARY;
    }
    // èŠ‚å‡æ—¥ç”¨çº¢è‰²
    if (day.holiday && day.holiday.dayType === 2) {
      return Constants.COLOR_DANGER;
    }
    // çœŸæ­£çš„24èŠ‚æ°”ç”¨ç»¿è‰²
    if (day.calendarInfo && this.isRealSolarTerm(day.calendarInfo.solarTerms)) {
      return Constants.COLOR_SUCCESS;
    }
    return Constants.COLOR_TEXT_TERTIARY;
  }

  /**
   * è·å–æ—¥æœŸæ–‡å­—é¢œè‰²
   */
  getDateTextColor(day: CalendarDay): string {
    if (!day.isCurrentMonth) {
      return Constants.COLOR_TEXT_TERTIARY;
    }
    if (day.isSelected) {
      return Constants.COLOR_PRIMARY_DARK;
    }
    if (day.isToday) {
      return Constants.COLOR_PRIMARY;
    }
    // å‘¨æœ«ç”¨çº¢è‰²
    const weekDay = day.date.getDay();
    if (weekDay === 0 || weekDay === 6) {
      return Constants.COLOR_DANGER;
    }
    if (day.holiday && day.holiday.dayType === 2) {
      return Constants.COLOR_DANGER;
    }
    return Constants.COLOR_TEXT_PRIMARY;
  }

  /**
   * æ„å»ºè¯¦æƒ…åŒºåŸŸ
   */
  @Builder
  buildDetailSection() {
    Column() {
      // æ—¥æœŸä¿¡æ¯
      Row() {
        Column() {
          Text(Utils.formatDate(this.selectedDate, 'MMæœˆDDæ—¥'))
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          
          Row() {
            Text(Utils.formatDate(this.selectedDate, 'YYYYå¹´'))
              .fontSize(13)
              .fontColor(Constants.COLOR_TEXT_SECONDARY)
            
            if (this.selectedCalendarInfo) {
              Text(`${this.selectedCalendarInfo.lunarCalendar}`)
                .fontSize(13)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
              
              Text(`${this.selectedCalendarInfo.yearTips}å¹´`)
                .fontSize(13)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
            }
          }
          .margin({ top: 4 })
          
          // èŠ‚æ°”ã€æ˜Ÿåº§ã€å±ç›¸
          if (this.selectedCalendarInfo) {
            Row() {
              if (this.isRealSolarTerm(this.selectedCalendarInfo.solarTerms)) {
                Text(`ğŸŒ¿ ${this.selectedCalendarInfo.solarTerms}`)
                  .fontSize(12)
                  .fontColor(Constants.COLOR_SUCCESS)
              }
              Text(`â­ ${this.selectedCalendarInfo.constellation}`)
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
              Text(`ğŸ¾ ${this.selectedCalendarInfo.chineseZodiac}`)
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
            }
            .margin({ top: 6 })
          }
        }
        .alignItems(HorizontalAlign.Start)

        Blank()

        // èŠ‚å‡æ—¥/å·¥ä½œæ—¥æ ‡ç­¾
        if (this.selectedCalendarInfo) {
          Column() {
            Text(this.selectedCalendarInfo.typeDes)
              .fontSize(14)
              .fontColor(this.selectedCalendarInfo.type === 0 ? Constants.COLOR_TEXT_SECONDARY : Constants.COLOR_PRIMARY)
              .fontWeight(FontWeight.Medium)
          }
          .padding({ left: 12, right: 12, top: 6, bottom: 6 })
          .backgroundColor(this.selectedCalendarInfo.type === 0 ? '#F5F5F5' : Constants.COLOR_PRIMARY_LIGHT)
          .borderRadius(16)
        }
      }
      .width('100%')
      .padding({ left: 16, right: 16, top: 16, bottom: 8 })

      // å®œå¿Œä¿¡æ¯
      if (this.selectedCalendarInfo && (this.selectedCalendarInfo.suit || this.selectedCalendarInfo.avoid)) {
        Column() {
          if (this.selectedCalendarInfo.suit) {
            Row() {
              Text('å®œ')
                .fontSize(12)
                .fontColor('#FFFFFF')
                .backgroundColor(Constants.COLOR_SUCCESS)
                .padding({ left: 6, right: 6, top: 2, bottom: 2 })
                .borderRadius(4)
              Text(this.selectedCalendarInfo.suit.replace(/\./g, ' '))
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
                .maxLines(1)
                .textOverflow({ overflow: TextOverflow.Ellipsis })
                .layoutWeight(1)
            }
            .width('100%')
            .margin({ bottom: 4 })
          }
          
          if (this.selectedCalendarInfo.avoid) {
            Row() {
              Text('å¿Œ')
                .fontSize(12)
                .fontColor('#FFFFFF')
                .backgroundColor(Constants.COLOR_DANGER)
                .padding({ left: 6, right: 6, top: 2, bottom: 2 })
                .borderRadius(4)
              Text(this.selectedCalendarInfo.avoid.replace(/\./g, ' '))
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
                .maxLines(1)
                .textOverflow({ overflow: TextOverflow.Ellipsis })
                .layoutWeight(1)
            }
            .width('100%')
          }
        }
        .width('100%')
        .padding({ left: 16, right: 16, bottom: 12 })
      }

      Divider()
        .color(Constants.COLOR_DIVIDER)
        .margin({ left: 16, right: 16 })

      // ä»»åŠ¡åˆ—è¡¨
      if (this.selectedDateTasks.length === 0) {
        Column() {
          Text('ğŸ“')
            .fontSize(40)
            .opacity(0.3)
          Text('è¿™ä¸€å¤©æ²¡æœ‰ä»»åŠ¡')
            .fontSize(14)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
            .margin({ top: 12 })
        }
        .width('100%')
        .height(120)
        .justifyContent(FlexAlign.Center)
      } else {
        Row() {
          Text('ä»»åŠ¡åˆ—è¡¨')
            .fontSize(15)
            .fontWeight(FontWeight.Medium)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          
          Blank()
          
          Text(`å…± ${this.selectedDateTasks.length} é¡¹`)
            .fontSize(12)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 12, bottom: 8 })

        List() {
          ForEach(this.selectedDateTasks, (task: Task) => {
            ListItem() {
              TaskItem({
                task: task,
                onTapAction: $tapActionId,
                onCompleteAction: $completeActionId,
                onDeleteAction: $deleteActionId
              })
            }
          })
        }
        .width('100%')
        .layoutWeight(1)
        .padding({ left: 16, right: 16 })
      }
    }
    .width('100%')
    .layoutWeight(1)
    .backgroundColor(Constants.COLOR_CARD_BACKGROUND)
    .borderRadius({ topLeft: 20, topRight: 20 })
    .padding({ bottom: 16 })
  }

  build() {
    Column() {
      // é¡¶éƒ¨æœˆä»½å¯¼èˆª
      Row() {
        Button('â€¹')
          .type(ButtonType.Normal)
          .fontSize(24)
          .fontColor(Constants.COLOR_TEXT_PRIMARY)
          .backgroundColor('transparent')
          .width(44)
          .height(44)
          .onClick(() => {
            this.prevMonth();
          })

        Blank()

        Column() {
          Text(`${this.currentMonth.getFullYear()}å¹´${this.currentMonth.getMonth() + 1}æœˆ`)
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          
          if (this.isLoading) {
            Text('åŠ è½½ä¸­...')
              .fontSize(11)
              .fontColor(Constants.COLOR_TEXT_TERTIARY)
          }
        }

        Blank()

        Button('â€º')
          .type(ButtonType.Normal)
          .fontSize(24)
          .fontColor(Constants.COLOR_TEXT_PRIMARY)
          .backgroundColor('transparent')
          .width(44)
          .height(44)
          .onClick(() => {
            this.nextMonth();
          })
      }
      .width('100%')
      .height(56)
      .padding({ left: 8, right: 8 })

      // æ—¥å†ç½‘æ ¼
      Column() {
        this.buildCalendarGrid()
      }
      .width('100%')
      .backgroundColor(Constants.COLOR_CARD_BACKGROUND)
      .borderRadius(12)
      .margin({ left: 16, right: 16, bottom: 12 })
      .padding({ top: 8, bottom: 8 })

      // è¯¦æƒ…åŒºåŸŸ
      if (this.showDetail) {
        this.buildDetailSection()
      } else {
        Column() {
          Text('ç‚¹å‡»æ—¥æœŸæŸ¥çœ‹è¯¦æƒ…')
            .fontSize(14)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
        }
        .width('100%')
        .padding({ top: 20, bottom: 20 })
      }
    }
    .width('100%')
    .flexGrow(1)
    .backgroundColor(Constants.COLOR_BACKGROUND)
  }
}
