import { TaskItem } from '../components/TaskItem';
import { TaskService } from '../service/TaskService';
import { HolidayService } from '../service/HolidayService';
import { Task } from '../model/Task';
import { Holiday } from '../model/Holiday';
import { Utils } from '../common/Utils';
import { Constants } from '../common/Constants';

/**
 * æ—¥å†æ—¥æœŸé¡¹
 */
interface CalendarDay {
  date: Date;
  isCurrentMonth: boolean;
  isToday: boolean;
  isSelected: boolean;
  taskCount: number;
  holidays: Holiday[];
  lunarDate: string; // å†œå†æ—¥æœŸå­—ç¬¦ä¸²ï¼ˆæš‚æ—¶ä¸ºç©ºï¼Œå¾…SDKæ”¯æŒåå®ç°ï¼‰
}

/**
 * æ—¥å†é¡µé¢ - å›ºå®šæ—¥å†ç½‘æ ¼å¸ƒå±€
 */
@Component
export struct CalendarPage {
  @State selectedDate: Date = new Date();
  @State currentMonth: Date = new Date();
  @State calendarDays: CalendarDay[] = [];
  @State selectedDateTasks: Task[] = [];
  @State allTasks: Task[] = [];
  @State holidays: Holiday[] = [];
  @State tapActionId: number = 0;
  @State completeActionId: number = 0;
  @State deleteActionId: number = 0;
  @State showDetail: boolean = false; // æ˜¯å¦æ˜¾ç¤ºè¯¦æƒ…

  private taskService: TaskService = TaskService.getInstance();
  private holidayService: HolidayService = HolidayService.getInstance();
  private today: Date = new Date();

  aboutToAppear() {
    this.loadTasks();
    this.loadHolidays();
    this.updateCalendarDays();
  }

  /**
   * åŠ è½½æ‰€æœ‰ä»»åŠ¡
   */
  async loadTasks(): Promise<void> {
    const tasks = await this.taskService.getAllTasks();
    this.allTasks = [...tasks];
    this.updateSelectedDateTasks();
    this.updateCalendarDays();
  }

  /**
   * åŠ è½½èŠ‚å‡æ—¥
   */
  async loadHolidays(): Promise<void> {
    const year = this.currentMonth.getFullYear();
    const month = this.currentMonth.getMonth();
    const loadedHolidays = await this.holidayService.getHolidaysByMonth(year, month);
    this.holidays = [...loadedHolidays];
    this.updateCalendarDays();
  }

  /**
   * æ›´æ–°æ—¥å†æ—¥æœŸæ•°ç»„
   */
  updateCalendarDays(): void {
    const days: CalendarDay[] = [];
    const year = this.currentMonth.getFullYear();
    const month = this.currentMonth.getMonth();
    
    // è·å–å½“æœˆç¬¬ä¸€å¤©å’Œæœ€åä¸€å¤©
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    
    // è·å–å½“æœˆç¬¬ä¸€å¤©æ˜¯æ˜ŸæœŸå‡ ï¼ˆ0=å‘¨æ—¥ï¼Œ1=å‘¨ä¸€...ï¼‰
    const firstDayWeek = firstDay.getDay();
    const startDay = firstDayWeek === 0 ? 6 : firstDayWeek - 1; // è½¬æ¢ä¸ºå‘¨ä¸€ä¸º0
    
    // è·å–ä¸Šä¸ªæœˆçš„æœ€åå‡ å¤©
    const prevMonthLastDay = new Date(year, month, 0).getDate();
    for (let i = startDay - 1; i >= 0; i--) {
      const date = new Date(year, month - 1, prevMonthLastDay - i);
      days.push(this.createCalendarDay(date, false));
    }
    
    // è·å–å½“æœˆçš„æ‰€æœ‰æ—¥æœŸ
    const daysInMonth = lastDay.getDate();
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      days.push(this.createCalendarDay(date, true));
    }
    
    // è¡¥é½åˆ°6è¡Œï¼ˆ42å¤©ï¼‰
    const remainingDays = 42 - days.length;
    for (let i = 1; i <= remainingDays; i++) {
      const date = new Date(year, month + 1, i);
      days.push(this.createCalendarDay(date, false));
    }
    
    this.calendarDays = [...days];
  }

  /**
   * è·å–å†œå†æ—¥æœŸå­—ç¬¦ä¸²
   * TODO: å¾…SDKæ”¯æŒ@kit.I18nKitåå®ç°
   */
  getLunarDate(date: Date): string {
    // æš‚æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œå¾…SDKæ”¯æŒå†œå†APIåå®ç°
    // ç¤ºä¾‹å®ç°ï¼ˆéœ€è¦@kit.I18nKitæ”¯æŒï¼‰ï¼š
    // const lunarCalendar = i18n.Calendar.getInstance('chinese');
    // lunarCalendar.setTime(date);
    // const lunarDay = lunarCalendar.getField('d');
    // return this.formatLunarDay(lunarDay);
    return '';
  }

  /**
   * æ ¼å¼åŒ–å†œå†æ—¥ä¸ºä¸­æ–‡æ•°å­—
   */
  formatLunarDay(day: number): string {
    const lunarDayNames = [
      'åˆä¸€', 'åˆäºŒ', 'åˆä¸‰', 'åˆå››', 'åˆäº”', 'åˆå…­', 'åˆä¸ƒ', 'åˆå…«', 'åˆä¹', 'åˆå',
      'åä¸€', 'åäºŒ', 'åä¸‰', 'åå››', 'åäº”', 'åå…­', 'åä¸ƒ', 'åå…«', 'åä¹', 'äºŒå',
      'å»¿ä¸€', 'å»¿äºŒ', 'å»¿ä¸‰', 'å»¿å››', 'å»¿äº”', 'å»¿å…­', 'å»¿ä¸ƒ', 'å»¿å…«', 'å»¿ä¹', 'ä¸‰å'
    ];
    if (day >= 0 && day < lunarDayNames.length) {
      return lunarDayNames[day];
    }
    return '';
  }

  /**
   * è·å–å®Œæ•´å†œå†æ—¥æœŸå­—ç¬¦ä¸²ï¼ˆç”¨äºè¯¦æƒ…æ˜¾ç¤ºï¼‰
   * TODO: å¾…SDKæ”¯æŒ@kit.I18nKitåå®ç°
   */
  getFullLunarDate(date: Date): string {
    // æš‚æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œå¾…SDKæ”¯æŒå†œå†APIåå®ç°
    return '';
  }

  /**
   * åˆ›å»ºæ—¥å†æ—¥æœŸé¡¹
   */
  createCalendarDay(date: Date, isCurrentMonth: boolean): CalendarDay {
    const isToday = Utils.isSameDay(date, this.today);
    const isSelected = Utils.isSameDay(date, this.selectedDate);
    const taskCount = this.getTaskCountForDate(date);
    const dateHolidays = this.getHolidaysForDate(date);
    const lunarDate = this.getLunarDate(date);
    
    return {
      date: date,
      isCurrentMonth: isCurrentMonth,
      isToday: isToday,
      isSelected: isSelected,
      taskCount: taskCount,
      holidays: dateHolidays,
      lunarDate: lunarDate
    };
  }

  /**
   * æ›´æ–°é€‰ä¸­æ—¥æœŸçš„ä»»åŠ¡
   */
  updateSelectedDateTasks(): void {
    const filtered = this.allTasks.filter(task => {
      if (!task.dueDate) return false;
      return Utils.isSameDay(task.dueDate, this.selectedDate);
    });
    this.selectedDateTasks = [...filtered];
  }

  /**
   * ç›‘å¬çŠ¶æ€å˜åŒ–
   */
  aboutToUpdate() {
    if (this.completeActionId > 0) {
      const task = this.allTasks.find(t => t.id === this.completeActionId);
      if (task) {
        this.onTaskComplete(task);
      }
      this.completeActionId = 0;
    }
    if (this.deleteActionId > 0) {
      const task = this.allTasks.find(t => t.id === this.deleteActionId);
      if (task) {
        this.onTaskDelete(task);
      }
      this.deleteActionId = 0;
    }
    if (this.tapActionId > 0) {
      const task = this.allTasks.find(t => t.id === this.tapActionId);
      if (task) {
        this.onTaskTap(task);
      }
      this.tapActionId = 0;
    }
    this.updateSelectedDateTasks();
  }

  /**
   * å®Œæˆä»»åŠ¡
   */
  async onTaskComplete(task: Task): Promise<void> {
    if (task.status === Constants.TASK_STATUS_COMPLETED) {
      await this.taskService.uncompleteTask(task);
    } else {
      await this.taskService.completeTask(task);
    }
    await this.loadTasks();
  }

  /**
   * åˆ é™¤ä»»åŠ¡
   */
  async onTaskDelete(task: Task): Promise<void> {
    await this.taskService.deleteTask(task.id);
    await this.loadTasks();
  }

  /**
   * è·³è½¬åˆ°ä»»åŠ¡è¯¦æƒ…/ç¼–è¾‘
   */
  onTaskTap(task: Task): void {
    console.info('ç‚¹å‡»ä»»åŠ¡:', task.title);
  }

  /**
   * é€‰æ‹©æ—¥æœŸ
   */
  onDateSelect(day: CalendarDay): void {
    if (!day.isCurrentMonth) {
      // å¦‚æœç‚¹å‡»çš„æ˜¯ä¸Šä¸ªæœˆæˆ–ä¸‹ä¸ªæœˆçš„æ—¥æœŸï¼Œåˆ‡æ¢æœˆä»½
      this.currentMonth = new Date(day.date.getFullYear(), day.date.getMonth(), 1);
      this.loadHolidays();
    }
    this.selectedDate = day.date;
    this.updateSelectedDateTasks();
    this.showDetail = true; // æ˜¾ç¤ºè¯¦æƒ…
  }

  /**
   * ä¸Šä¸€ä¸ªæœˆ
   */
  prevMonth(): void {
    const newMonth = new Date(this.currentMonth);
    newMonth.setMonth(newMonth.getMonth() - 1);
    this.currentMonth = newMonth;
    this.loadHolidays();
    this.updateCalendarDays();
  }

  /**
   * ä¸‹ä¸€ä¸ªæœˆ
   */
  nextMonth(): void {
    const newMonth = new Date(this.currentMonth);
    newMonth.setMonth(newMonth.getMonth() + 1);
    this.currentMonth = newMonth;
    this.loadHolidays();
    this.updateCalendarDays();
  }

  /**
   * è·å–æ—¥æœŸå¯¹åº”çš„èŠ‚å‡æ—¥
   */
  getHolidaysForDate(date: Date): Holiday[] {
    return this.holidays.filter(holiday => {
      return Utils.isSameDay(date, holiday.date);
    });
  }

  /**
   * è·å–æ—¥æœŸå¯¹åº”çš„ä»»åŠ¡æ•°é‡
   */
  getTaskCountForDate(date: Date): number {
    return this.allTasks.filter(task => {
      if (!task.dueDate) return false;
      return Utils.isSameDay(date, task.dueDate);
    }).length;
  }

  /**
   * æ„å»ºæ—¥å†ç½‘æ ¼
   */
  @Builder
  buildCalendarGrid() {
    Column() {
      // æ˜ŸæœŸæ ‡é¢˜è¡Œ
      Row() {
        ForEach(['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'æ—¥'], (day: string) => {
          Text(day)
            .fontSize(14)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
            .width('14.28%')
            .textAlign(TextAlign.Center)
        })
      }
      .width('100%')
      .height(40)
      .padding({ left: 8, right: 8 })

      // æ—¥æœŸç½‘æ ¼
      Grid() {
        ForEach(this.calendarDays, (day: CalendarDay) => {
          GridItem() {
            this.buildCalendarDay(day)
          }
        })
      }
      .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')
      .rowsTemplate('1fr 1fr 1fr 1fr 1fr 1fr')
      .width('100%')
      .height(360)
      .padding({ left: 8, right: 8, top: 8, bottom: 8 })
    }
    .width('100%')
  }

  /**
   * æ„å»ºå•ä¸ªæ—¥æœŸå•å…ƒæ ¼
   */
  @Builder
  buildCalendarDay(day: CalendarDay) {
    Column() {
      // æ—¥æœŸæ•°å­—
      Text(`${day.date.getDate()}`)
        .fontSize(16)
        .fontWeight(day.isToday || day.isSelected ? FontWeight.Bold : FontWeight.Normal)
        .fontColor(this.getDateTextColor(day))
        .margin({ bottom: 2 })

      // å†œå†æ—¥æœŸ
      if (day.lunarDate && day.isCurrentMonth) {
        Text(day.lunarDate)
          .fontSize(10)
          .fontColor(this.getLunarTextColor(day))
          .margin({ bottom: 2 })
      }

      // ä»»åŠ¡/èŠ‚å‡æ—¥æ ‡è®°
      if (day.taskCount > 0 || day.holidays.length > 0) {
        Row() {
          if (day.taskCount > 0) {
            Text('â—')
              .fontSize(8)
              .fontColor(Constants.COLOR_PRIMARY)
          }
          if (day.holidays.length > 0) {
            Text('â—')
              .fontSize(8)
              .fontColor(Constants.COLOR_DANGER)
              .margin({ left: day.taskCount > 0 ? 2 : 0 })
          }
        }
        .justifyContent(FlexAlign.Center)
        .height(12)
      }
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .backgroundColor(day.isSelected ? Constants.COLOR_PRIMARY_LIGHT : 'transparent')
    .borderRadius(8)
    .onClick(() => {
      this.onDateSelect(day);
    })
  }

  /**
   * è·å–å†œå†æ–‡å­—é¢œè‰²
   */
  getLunarTextColor(day: CalendarDay): string {
    if (!day.isCurrentMonth) {
      return Constants.COLOR_TEXT_TERTIARY;
    }
    if (day.holidays.length > 0) {
      return Constants.COLOR_DANGER;
    }
    return Constants.COLOR_TEXT_SECONDARY;
  }

  /**
   * è·å–æ—¥æœŸæ–‡å­—é¢œè‰²
   */
  getDateTextColor(day: CalendarDay): string {
    if (!day.isCurrentMonth) {
      return Constants.COLOR_TEXT_TERTIARY;
    }
    if (day.isToday || day.isSelected) {
      return Constants.COLOR_PRIMARY;
    }
    if (day.holidays.length > 0) {
      return Constants.COLOR_DANGER;
    }
    return Constants.COLOR_TEXT_PRIMARY;
  }

  /**
   * æ„å»ºè¯¦æƒ…åŒºåŸŸ
   */
  @Builder
  buildDetailSection() {
    Column() {
      // æ—¥æœŸä¿¡æ¯
      Row() {
        Column() {
          Text(Utils.formatDate(this.selectedDate, 'MMæœˆDDæ—¥'))
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          Row() {
            Text(Utils.formatDate(this.selectedDate, 'YYYYå¹´'))
              .fontSize(12)
              .fontColor(Constants.COLOR_TEXT_SECONDARY)
            if (this.getFullLunarDate(this.selectedDate)) {
              Text(this.getFullLunarDate(this.selectedDate))
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
            }
          }
          .margin({ top: 4 })
        }
        .alignItems(HorizontalAlign.Start)

        Blank()

        // èŠ‚å‡æ—¥æ˜¾ç¤º
        if (this.getHolidaysForDate(this.selectedDate).length > 0) {
          Row() {
            Text('ğŸ‰')
              .fontSize(16)
            Text(this.getHolidaysForDate(this.selectedDate)[0].name)
              .fontSize(14)
              .fontColor(Constants.COLOR_PRIMARY)
              .margin({ left: 4 })
          }
          .padding({ left: 12, right: 12, top: 6, bottom: 6 })
          .backgroundColor(Constants.COLOR_PRIMARY_LIGHT)
          .borderRadius(16)
        }
      }
      .width('100%')
      .padding({ left: 16, right: 16, top: 16, bottom: 12 })

      // ä»»åŠ¡åˆ—è¡¨
      if (this.selectedDateTasks.length === 0) {
        Column() {
          Text('ğŸ“')
            .fontSize(48)
            .opacity(0.3)
          Text('è¿™ä¸€å¤©æ²¡æœ‰ä»»åŠ¡')
            .fontSize(16)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
            .margin({ top: 16 })
        }
        .width('100%')
        .height(150)
        .justifyContent(FlexAlign.Center)
      } else {
        Row() {
          Text('ä»»åŠ¡åˆ—è¡¨')
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          
          Blank()
          
          Text(`å…± ${this.selectedDateTasks.length} é¡¹`)
            .fontSize(12)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 12, bottom: 8 })

        List() {
          ForEach(this.selectedDateTasks, (task: Task) => {
            ListItem() {
              TaskItem({
                task: task,
                onTapAction: $tapActionId,
                onCompleteAction: $completeActionId,
                onDeleteAction: $deleteActionId
              })
            }
          })
        }
        .width('100%')
        .layoutWeight(1)
        .padding({ left: 16, right: 16 })
      }
    }
    .width('100%')
    .layoutWeight(1)
    .backgroundColor(Constants.COLOR_CARD_BACKGROUND)
    .borderRadius({ topLeft: 20, topRight: 20 })
    .padding({ bottom: 16 })
  }

  build() {
    Column() {
      // é¡¶éƒ¨æœˆä»½å¯¼èˆª
      Row() {
        Button('â€¹')
          .type(ButtonType.Normal)
          .fontSize(20)
          .fontColor(Constants.COLOR_TEXT_PRIMARY)
          .backgroundColor('transparent')
          .width(40)
          .height(40)
          .onClick(() => {
            this.prevMonth();
          })

        Blank()

        Text(`${this.currentMonth.getFullYear()}å¹´${this.currentMonth.getMonth() + 1}æœˆ`)
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .fontColor(Constants.COLOR_TEXT_PRIMARY)

        Blank()

        Button('â€º')
          .type(ButtonType.Normal)
          .fontSize(20)
          .fontColor(Constants.COLOR_TEXT_PRIMARY)
          .backgroundColor('transparent')
          .width(40)
          .height(40)
          .onClick(() => {
            this.nextMonth();
          })
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16 })

      // æ—¥å†ç½‘æ ¼
      Column() {
        this.buildCalendarGrid()
      }
      .width('100%')
      .backgroundColor(Constants.COLOR_CARD_BACKGROUND)
      .borderRadius(12)
      .margin({ left: 16, right: 16, bottom: 12 })
      .padding({ top: 12, bottom: 12 })

      // è¯¦æƒ…åŒºåŸŸï¼ˆå¯ä¸‹æ‹‰å±•å¼€ï¼‰
      if (this.showDetail) {
        this.buildDetailSection()
      } else {
        // åº•éƒ¨æç¤º
        Column() {
          Text('ç‚¹å‡»æ—¥æœŸæŸ¥çœ‹è¯¦æƒ…')
            .fontSize(14)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
            .margin({ bottom: 8 })
          Text('â†“')
            .fontSize(20)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
            .opacity(0.5)
        }
        .width('100%')
        .padding({ top: 20, bottom: 20 })
      }
    }
    .width('100%')
    .flexGrow(1)
    .backgroundColor(Constants.COLOR_BACKGROUND)
  }
}
