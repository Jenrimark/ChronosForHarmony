import { CalendarViewType, CalendarEvent } from '../model/CalendarEvent';
import { Holiday, MxnzpHolidayData } from '../model/Holiday';
import { Task } from '../model/Task';
import { TaskService } from '../service/TaskService';
import { HolidayService } from '../service/HolidayService';
import { EventService } from '../service/EventService';
import { Utils } from '../common/Utils';
import { Constants } from '../common/Constants';
import { TaskItem } from '../components/TaskItem';

// ç»„ä»¶å¯¼å…¥
import { ViewTabs } from '../components/calendar/ViewTabs';
import { DateCell, CalendarDayData } from '../components/calendar/DateCell';
import { YearView } from '../components/calendar/YearView';
import { WeekView } from '../components/calendar/WeekView';
import { DayView } from '../components/calendar/DayView';
import { EventSheet } from '../components/calendar/EventSheet';
import { CalendarMenu, JumpToDateSheet, SearchEventSheet, SearchResultItem } from '../components/calendar/CalendarMenu';

/**
 * å¢å¼ºç‰ˆæ—¥å†é¡µé¢
 * æ”¯æŒå¹´/æœˆ/å‘¨/æ—¥å››ç§è§†å›¾
 */
@Component
export struct CalendarNewPage {
  @State currentView: CalendarViewType = CalendarViewType.MONTH;
  @State selectedDate: Date = new Date();
  @State currentMonth: Date = new Date();
  @State currentYear: number = new Date().getFullYear();
  @State calendarDays: CalendarDayData[] = [];
  @State events: CalendarEvent[] = [];
  @State allTasks: Task[] = [];
  @State selectedDateTasks: Task[] = [];
  @State selectedDateEvents: CalendarEvent[] = [];
  @State selectedCalendarInfo: MxnzpHolidayData | null = null;
  @State isLoading: boolean = false;
  @State showDetail: boolean = false;
  
  // å¼¹çª—çŠ¶æ€
  @State showEventSheet: boolean = false;
  @State showMenu: boolean = false;
  @State showJumpDate: boolean = false;
  @State showSearch: boolean = false;
  @State editingEvent: CalendarEvent | null = null;
  
  // æ»‘åŠ¨ç›¸å…³
  private swipeStartX: number = 0;

  private taskService: TaskService = TaskService.getInstance();
  private holidayService: HolidayService = HolidayService.getInstance();
  private eventService: EventService = EventService.getInstance();
  private today: Date = new Date();
  
  // 24èŠ‚æ°”åˆ—è¡¨
  private readonly solarTermsList: string[] = [
    'ç«‹æ˜¥', 'é›¨æ°´', 'æƒŠè›°', 'æ˜¥åˆ†', 'æ¸…æ˜', 'è°·é›¨',
    'ç«‹å¤', 'å°æ»¡', 'èŠ’ç§', 'å¤è‡³', 'å°æš‘', 'å¤§æš‘',
    'ç«‹ç§‹', 'å¤„æš‘', 'ç™½éœ²', 'ç§‹åˆ†', 'å¯’éœ²', 'éœœé™',
    'ç«‹å†¬', 'å°é›ª', 'å¤§é›ª', 'å†¬è‡³', 'å°å¯’', 'å¤§å¯’'
  ];

  aboutToAppear() {
    this.loadData();
  }

  /**
   * åŠ è½½æ‰€æœ‰æ•°æ®
   */
  async loadData(): Promise<void> {
    await this.loadTasks();
    await this.loadEvents();
    await this.loadCalendarData();
  }

  /**
   * åŠ è½½ä»»åŠ¡
   */
  async loadTasks(): Promise<void> {
    this.allTasks = await this.taskService.getAllTasks();
    this.updateSelectedDateTasks();
  }

  /**
   * æ›´æ–°é€‰ä¸­æ—¥æœŸçš„ä»»åŠ¡
   */
  updateSelectedDateTasks(): void {
    const filtered = this.allTasks.filter(task => {
      if (!task.dueDate) return false;
      return Utils.isSameDay(task.dueDate, this.selectedDate);
    });
    this.selectedDateTasks = [...filtered];
  }

  /**
   * æ›´æ–°é€‰ä¸­æ—¥æœŸçš„æ—¥ç¨‹äº‹ä»¶
   */
  updateSelectedDateEvents(): void {
    const filtered = this.events.filter(event => event.isOnDate(this.selectedDate));
    this.selectedDateEvents = [...filtered];
  }

  /**
   * åˆ¤æ–­æ˜¯å¦æ˜¯çœŸæ­£çš„24èŠ‚æ°”
   */
  isRealSolarTerm(solarTerms: string): boolean {
    if (!solarTerms || solarTerms === 'æ— ') {
      return false;
    }
    if (solarTerms.includes('å') || solarTerms.includes('å‰')) {
      return false;
    }
    return this.solarTermsList.includes(solarTerms);
  }

  /**
   * å®Œæˆä»»åŠ¡
   */
  async onTaskComplete(task: Task): Promise<void> {
    if (task.status === Constants.TASK_STATUS_COMPLETED) {
      await this.taskService.uncompleteTask(task);
    } else {
      await this.taskService.completeTask(task);
    }
    await this.loadTasks();
  }

  /**
   * åˆ é™¤ä»»åŠ¡
   */
  async onTaskDelete(task: Task): Promise<void> {
    await this.taskService.deleteTask(task);
    await this.loadTasks();
  }

  /**
   * åŠ è½½æ—¥ç¨‹äº‹ä»¶
   */
  async loadEvents(): Promise<void> {
    this.events = await this.eventService.getAllEvents();
    this.updateSelectedDateEvents();
  }

  /**
   * åŠ è½½æ—¥å†æ•°æ®
   */
  async loadCalendarData(): Promise<void> {
    this.isLoading = true;
    const year = this.currentMonth.getFullYear();
    const month = this.currentMonth.getMonth();
    
    const startDate = new Date(year, month, 1);
    const endDate = new Date(year, month + 1, 0);
    
    const currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      await this.holidayService.getHolidayByDate(new Date(currentDate));
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    this.updateCalendarDays();
    this.isLoading = false;
    await this.loadSelectedDateInfo();
  }

  /**
   * åŠ è½½é€‰ä¸­æ—¥æœŸä¿¡æ¯
   */
  async loadSelectedDateInfo(): Promise<void> {
    this.selectedCalendarInfo = await this.holidayService.getCalendarInfo(this.selectedDate);
    
    // è°ƒè¯•æ—¥å¿—
    if (this.selectedCalendarInfo) {
      console.info(`CalendarNew: é€‰ä¸­æ—¥æœŸä¿¡æ¯ - suit: "${this.selectedCalendarInfo.suit}", avoid: "${this.selectedCalendarInfo.avoid}"`);
      console.info(`CalendarNew: å®Œæ•´calendarInfo:`, JSON.stringify(this.selectedCalendarInfo));
    } else {
      console.warn('CalendarNew: selectedCalendarInfo ä¸º null');
    }
    
    this.updateSelectedDateTasks();
    this.updateSelectedDateEvents();
    this.showDetail = true;
  }

  /**
   * æ›´æ–°æ—¥å†æ—¥æœŸæ•°ç»„
   */
  updateCalendarDays(): void {
    const days: CalendarDayData[] = [];
    const year = this.currentMonth.getFullYear();
    const month = this.currentMonth.getMonth();
    
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const firstDayWeek = firstDay.getDay();
    const startDay = firstDayWeek === 0 ? 6 : firstDayWeek - 1;
    
    // ä¸Šæœˆæ—¥æœŸ
    const prevMonthLastDay = new Date(year, month, 0).getDate();
    for (let i = startDay - 1; i >= 0; i--) {
      const date = new Date(year, month - 1, prevMonthLastDay - i);
      days.push(this.createCalendarDay(date, false));
    }
    
    // å½“æœˆæ—¥æœŸ
    const daysInMonth = lastDay.getDate();
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      days.push(this.createCalendarDay(date, true));
    }
    
    // ä¸‹æœˆæ—¥æœŸ
    const remainingDays = 42 - days.length;
    for (let i = 1; i <= remainingDays; i++) {
      const date = new Date(year, month + 1, i);
      days.push(this.createCalendarDay(date, false));
    }
    
    this.calendarDays = days;
  }

  /**
   * åˆ›å»ºæ—¥å†æ—¥æœŸé¡¹
   */
  createCalendarDay(date: Date, isCurrentMonth: boolean): CalendarDayData {
    const day = new CalendarDayData();
    day.date = date;
    day.isCurrentMonth = isCurrentMonth;
    day.isToday = Utils.isSameDay(date, this.today);
    day.isSelected = Utils.isSameDay(date, this.selectedDate);
    day.taskCount = this.getTaskCountForDate(date);
    day.eventCount = this.getEventCountForDate(date);
    
    const dateKey = this.getDateKey(date);
    day.calendarInfo = this.holidayService.getCalendarFromCache(dateKey);
    day.holiday = this.holidayService.getHolidayFromCache(dateKey);
    
    return day;
  }

  /**
   * è·å–æ—¥æœŸé”®
   */
  getDateKey(date: Date): string {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  /**
   * è·å–ä»»åŠ¡æ•°é‡
   */
  getTaskCountForDate(date: Date): number {
    return this.allTasks.filter(task => {
      if (!task.dueDate) return false;
      return Utils.isSameDay(date, task.dueDate);
    }).length;
  }

  /**
   * è·å–äº‹ä»¶æ•°é‡
   */
  getEventCountForDate(date: Date): number {
    return this.events.filter(event => event.isOnDate(date)).length;
  }

  /**
   * è§†å›¾åˆ‡æ¢
   */
  onViewChange(view: CalendarViewType): void {
    this.currentView = view;
    if (view === CalendarViewType.YEAR) {
      this.currentYear = this.selectedDate.getFullYear();
    }
  }

  /**
   * é€‰æ‹©æ—¥æœŸ
   */
  async onDateSelect(day: CalendarDayData): Promise<void> {
    if (!day.isCurrentMonth) {
      this.currentMonth = new Date(day.date.getFullYear(), day.date.getMonth(), 1);
      await this.loadCalendarData();
    }
    this.selectedDate = day.date;
    this.updateCalendarDays();
    await this.loadSelectedDateInfo();
  }

  /**
   * ä»å¹´è§†å›¾é€‰æ‹©æœˆä»½
   */
  async onMonthSelect(year: number, month: number): Promise<void> {
    this.currentMonth = new Date(year, month, 1);
    this.selectedDate = new Date(year, month, 1);
    this.currentView = CalendarViewType.MONTH;
    await this.loadCalendarData();
  }

  /**
   * ä¸Šä¸€ä¸ªæœˆ/å¹´
   */
  async prevPeriod(): Promise<void> {
    if (this.currentView === CalendarViewType.YEAR) {
      this.currentYear--;
    } else {
      const newMonth = new Date(this.currentMonth);
      newMonth.setMonth(newMonth.getMonth() - 1);
      this.currentMonth = newMonth;
      await this.loadCalendarData();
    }
  }

  /**
   * ä¸‹ä¸€ä¸ªæœˆ/å¹´
   */
  async nextPeriod(): Promise<void> {
    if (this.currentView === CalendarViewType.YEAR) {
      this.currentYear++;
    } else {
      const newMonth = new Date(this.currentMonth);
      newMonth.setMonth(newMonth.getMonth() + 1);
      this.currentMonth = newMonth;
      await this.loadCalendarData();
    }
  }

  /**
   * æ–°å»ºæ—¥ç¨‹
   */
  createEvent(): void {
    this.editingEvent = null;
    this.showEventSheet = true;
  }

  /**
   * ç¼–è¾‘æ—¥ç¨‹
   */
  editEvent(event: CalendarEvent): void {
    this.editingEvent = event;
    this.showEventSheet = true;
  }

  /**
   * ä¿å­˜æ—¥ç¨‹
   */
  async saveEvent(event: CalendarEvent): Promise<void> {
    if (event.id > 0) {
      await this.eventService.updateEvent(event);
    } else {
      await this.eventService.createEvent(event);
    }
    await this.loadEvents();
    this.updateCalendarDays();
  }

  /**
   * åˆ é™¤æ—¥ç¨‹
   */
  async deleteEvent(event: CalendarEvent): Promise<void> {
    await this.eventService.deleteEvent(event.id);
    await this.loadEvents();
    this.updateCalendarDays();
    this.updateSelectedDateEvents();
  }

  /**
   * æ„å»ºæ—¥ç¨‹é¡¹
   */
  @Builder
  buildEventItem(event: CalendarEvent) {
    Row() {
      // æ—¶é—´
      Column() {
        if (event.isAllDay) {
          Text('å…¨å¤©')
            .fontSize(12)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
        } else {
          Text(Utils.formatDate(event.startTime, 'HH:mm'))
            .fontSize(14)
            .fontWeight(FontWeight.Medium)
            .fontColor(Constants.COLOR_PRIMARY)
          if (event.endTime) {
            Text(Utils.formatDate(event.endTime, 'HH:mm'))
              .fontSize(12)
              .fontColor(Constants.COLOR_TEXT_SECONDARY)
              .margin({ top: 2 })
          }
        }
      }
      .width(60)
      .alignItems(HorizontalAlign.Center)

      // æ—¥ç¨‹ä¿¡æ¯
      Column() {
        Text(event.title)
          .fontSize(16)
          .fontWeight(FontWeight.Medium)
          .fontColor(Constants.COLOR_TEXT_PRIMARY)
          .maxLines(2)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
        
        if (event.location) {
          Text(`ğŸ“ ${event.location}`)
            .fontSize(13)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
            .margin({ top: 4 })
            .maxLines(1)
            .textOverflow({ overflow: TextOverflow.Ellipsis })
        }
      }
      .alignItems(HorizontalAlign.Start)
      .layoutWeight(1)
      .margin({ left: 12 })

      // é‡è¦æ ‡è®°
      if (event.priority) {
        Text('â­')
          .fontSize(18)
      }
    }
    .width('100%')
    .padding(16)
    .backgroundColor(Constants.COLOR_CARD_BACKGROUND)
    .borderRadius(12)
    .margin({ bottom: 8 })
    .onClick(() => {
      this.editEvent(event);
    })
  }

  /**
   * è·³è½¬åˆ°æ—¥æœŸ
   */
  async jumpToDate(date: Date): Promise<void> {
    this.selectedDate = date;
    this.currentMonth = new Date(date.getFullYear(), date.getMonth(), 1);
    this.currentYear = date.getFullYear();
    await this.loadCalendarData();
  }

  /**
   * æœç´¢æ—¥ç¨‹
   */
  async searchEvents(keyword: string): Promise<SearchResultItem[]> {
    const results = await this.eventService.searchEvents(keyword);
    return results.map(event => {
      const item = new SearchResultItem();
      item.id = event.id;
      item.title = event.title;
      item.date = event.startTime;
      return item;
    });
  }

  /**
   * è·å–æ ‡é¢˜æ–‡æœ¬
   */
  getTitleText(): string {
    if (this.currentView === CalendarViewType.YEAR) {
      return `${this.currentYear}å¹´`;
    }
    return `${this.currentMonth.getFullYear()}å¹´${this.currentMonth.getMonth() + 1}æœˆ`;
  }

  /**
   * æ„å»ºæœˆè§†å›¾
   */
  @Builder
  buildMonthView() {
    Column() {
      // æ˜ŸæœŸæ ‡é¢˜
      Row() {
        ForEach(['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'æ—¥'], (day: string, index: number) => {
          Text(day)
            .fontSize(14)
            .fontColor(index >= 5 ? Constants.COLOR_DANGER : Constants.COLOR_TEXT_SECONDARY)
            .width('14.28%')
            .textAlign(TextAlign.Center)
        })
      }
      .width('100%')
      .height(40)
      .padding({ left: 8, right: 8 })

      // æ—¥æœŸç½‘æ ¼ï¼ˆæ”¯æŒæ»‘åŠ¨ç¿»é¡µï¼‰
      Grid() {
        ForEach(this.calendarDays, (day: CalendarDayData) => {
          GridItem() {
            DateCell({
              day: day,
              onSelect: (d: CalendarDayData) => {
                this.onDateSelect(d);
              }
            })
          }
        })
      }
      .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')
      .rowsTemplate('1fr 1fr 1fr 1fr 1fr 1fr')
      .width('100%')
      .height(360)
      .padding({ left: 8, right: 8, top: 8, bottom: 8 })
    }
    .width('100%')
    .backgroundColor(Constants.COLOR_CARD_BACKGROUND)
    .borderRadius(12)
    .margin({ left: 16, right: 16, bottom: 12 })
    .padding({ top: 8, bottom: 8 })
    .gesture(
      PanGesture({ direction: PanDirection.Horizontal })
        .onActionStart((event: GestureEvent) => {
          this.swipeStartX = event.offsetX;
        })
        .onActionEnd((event: GestureEvent) => {
          const deltaX = event.offsetX - this.swipeStartX;
          if (Math.abs(deltaX) > 50) {
            if (deltaX > 0) {
              this.prevPeriod();
            } else {
              this.nextPeriod();
            }
          }
        })
    )
  }

  /**
   * æ„å»ºè¯¦æƒ…åŒºåŸŸ
   */
  @Builder
  buildDetailSection() {
    Column() {
      // æ—¥æœŸä¿¡æ¯
      Row() {
        Column() {
          Text(Utils.formatDate(this.selectedDate, 'MMæœˆDDæ—¥'))
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          
          Row() {
            Text(Utils.formatDate(this.selectedDate, 'YYYYå¹´'))
              .fontSize(13)
              .fontColor(Constants.COLOR_TEXT_SECONDARY)
            
            if (this.selectedCalendarInfo) {
              Text(`${this.selectedCalendarInfo.lunarCalendar}`)
                .fontSize(13)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
              
              Text(`${this.selectedCalendarInfo.yearTips}å¹´`)
                .fontSize(13)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
            }
          }
          .margin({ top: 4 })
          
          // èŠ‚æ°”ã€æ˜Ÿåº§ã€å±ç›¸
          if (this.selectedCalendarInfo) {
            Row() {
              if (this.isRealSolarTerm(this.selectedCalendarInfo.solarTerms)) {
                Text(`ğŸŒ¿ ${this.selectedCalendarInfo.solarTerms}`)
                  .fontSize(12)
                  .fontColor(Constants.COLOR_SUCCESS)
              }
              Text(`â­ ${this.selectedCalendarInfo.constellation}`)
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
              Text(`ğŸ¾ ${this.selectedCalendarInfo.chineseZodiac}`)
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
            }
            .margin({ top: 6 })
          }
        }
        .alignItems(HorizontalAlign.Start)

        Blank()

        // èŠ‚å‡æ—¥/å·¥ä½œæ—¥æ ‡ç­¾
        if (this.selectedCalendarInfo) {
          Column() {
            Text(this.selectedCalendarInfo.typeDes)
              .fontSize(14)
              .fontColor(this.selectedCalendarInfo.type === 0 ? Constants.COLOR_TEXT_SECONDARY : '#FFFFFF')
              .fontWeight(FontWeight.Medium)
          }
          .padding({ left: 12, right: 12, top: 6, bottom: 6 })
          .backgroundColor(this.selectedCalendarInfo.type === 0 ? '#F5F5F5' : Constants.COLOR_PRIMARY)
          .borderRadius(16)
        }
      }
      .width('100%')
      .padding({ left: 16, right: 16, top: 16, bottom: 8 })

      // å®œå¿Œä¿¡æ¯ï¼ˆAPIæ•°æ®æºæ—¶æ˜¾ç¤ºï¼‰
      if (this.selectedCalendarInfo && 
          (this.selectedCalendarInfo.suit && this.selectedCalendarInfo.suit.trim() || 
           this.selectedCalendarInfo.avoid && this.selectedCalendarInfo.avoid.trim())) {
        Column() {
          if (this.selectedCalendarInfo.suit && this.selectedCalendarInfo.suit.trim()) {
            Row() {
              Text('å®œ')
                .fontSize(12)
                .fontColor('#FFFFFF')
                .backgroundColor(Constants.COLOR_SUCCESS)
                .padding({ left: 6, right: 6, top: 2, bottom: 2 })
                .borderRadius(4)
              Text(this.selectedCalendarInfo.suit.replace(/\./g, ' ').trim())
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
                .maxLines(2)
                .textOverflow({ overflow: TextOverflow.Ellipsis })
                .layoutWeight(1)
            }
            .width('100%')
            .margin({ bottom: 4 })
          }
          
          if (this.selectedCalendarInfo.avoid && this.selectedCalendarInfo.avoid.trim()) {
            Row() {
              Text('å¿Œ')
                .fontSize(12)
                .fontColor('#FFFFFF')
                .backgroundColor(Constants.COLOR_DANGER)
                .padding({ left: 6, right: 6, top: 2, bottom: 2 })
                .borderRadius(4)
              Text(this.selectedCalendarInfo.avoid.replace(/\./g, ' ').trim())
                .fontSize(12)
                .fontColor(Constants.COLOR_TEXT_SECONDARY)
                .margin({ left: 8 })
                .maxLines(2)
                .textOverflow({ overflow: TextOverflow.Ellipsis })
                .layoutWeight(1)
            }
            .width('100%')
          }
        }
        .width('100%')
        .padding({ left: 16, right: 16, bottom: 12 })
      }

      Divider()
        .color(Constants.COLOR_DIVIDER)
        .margin({ left: 16, right: 16 })

      // æ—¥ç¨‹åˆ—è¡¨ï¼ˆåœ¨ä»»åŠ¡åˆ—è¡¨ä¹‹å‰ï¼‰
      if (this.selectedDateEvents.length > 0) {
        Row() {
          Text('æ—¥ç¨‹å®‰æ’')
            .fontSize(15)
            .fontWeight(FontWeight.Medium)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          
          Blank()
          
          Text(`å…± ${this.selectedDateEvents.length} é¡¹`)
            .fontSize(12)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 12, bottom: 8 })

        Column() {
          ForEach(this.selectedDateEvents, (event: CalendarEvent) => {
            this.buildEventItem(event)
          })
        }
        .width('100%')
        .padding({ left: 16, right: 16, bottom: 16 })
      }

      // ä»»åŠ¡åˆ—è¡¨
      if (this.selectedDateTasks.length > 0) {
        Row() {
          Text('ä»»åŠ¡åˆ—è¡¨')
            .fontSize(15)
            .fontWeight(FontWeight.Medium)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
          
          Blank()
          
          Text(`å…± ${this.selectedDateTasks.length} é¡¹`)
            .fontSize(12)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: this.selectedDateEvents.length > 0 ? 12 : 12, bottom: 8 })

        Column() {
          ForEach(this.selectedDateTasks, (task: Task) => {
            TaskItem({
              task: task,
              onTap: (task: Task) => {
                // ç‚¹å‡»ä»»åŠ¡çš„å¤„ç†ï¼ˆå¯ä»¥æ‰“å¼€è¯¦æƒ…æˆ–ç¼–è¾‘ï¼‰
              },
              onComplete: (task: Task) => {
                this.onTaskComplete(task);
              },
              onDelete: (task: Task) => {
                this.onTaskDelete(task);
              }
            })
            .margin({ bottom: 8 })
          })
        }
        .width('100%')
        .padding({ left: 16, right: 16, bottom: 16 })
      }

      // å¦‚æœæ²¡æœ‰ä»»åŠ¡å’Œæ—¥ç¨‹ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
      if (this.selectedDateTasks.length === 0 && this.selectedDateEvents.length === 0) {
        Column() {
          Text('ğŸ“…')
            .fontSize(40)
            .opacity(0.3)
          Text('è¿™ä¸€å¤©æ²¡æœ‰ä»»åŠ¡å’Œæ—¥ç¨‹')
            .fontSize(14)
            .fontColor(Constants.COLOR_TEXT_SECONDARY)
            .margin({ top: 12 })
        }
        .width('100%')
        .height(120)
        .justifyContent(FlexAlign.Center)
      }
    }
    .width('100%')
    .backgroundColor(Constants.COLOR_CARD_BACKGROUND)
    .borderRadius({ topLeft: 20, topRight: 20 })
    .padding({ bottom: 16 })
    .flexShrink(0)
  }

  build() {
    Stack() {
      Column() {
        // é¡¶éƒ¨å¯¼èˆª
        Row() {
          Button('â€¹')
            .type(ButtonType.Normal)
            .fontSize(24)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
            .backgroundColor(Color.Transparent)
            .width(44)
            .height(44)
            .onClick(() => this.prevPeriod())

          Blank()

          Column() {
            Text(this.getTitleText())
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor(Constants.COLOR_TEXT_PRIMARY)
            
            if (this.isLoading) {
              Text('åŠ è½½ä¸­...')
                .fontSize(11)
                .fontColor(Constants.COLOR_TEXT_TERTIARY)
            }
          }

          Blank()

          // èœå•æŒ‰é’®
          Button('â‹®')
            .type(ButtonType.Normal)
            .fontSize(20)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
            .backgroundColor(Color.Transparent)
            .width(44)
            .height(44)
            .onClick(() => {
              this.showMenu = !this.showMenu;
            })

          Button('â€º')
            .type(ButtonType.Normal)
            .fontSize(24)
            .fontColor(Constants.COLOR_TEXT_PRIMARY)
            .backgroundColor(Color.Transparent)
            .width(44)
            .height(44)
            .onClick(() => this.nextPeriod())
        }
        .width('100%')
        .height(56)
        .padding({ left: 8, right: 8 })

        // è§†å›¾åˆ‡æ¢æ ‡ç­¾
        ViewTabs({
          currentView: $currentView,
          onViewChange: (view: CalendarViewType) => this.onViewChange(view)
        })

        // è§†å›¾å†…å®¹
        if (this.currentView === CalendarViewType.YEAR) {
          YearView({
            currentYear: this.currentYear,
            selectedDate: $selectedDate,
            onMonthSelect: (year: number, month: number) => this.onMonthSelect(year, month)
          })
        } else if (this.currentView === CalendarViewType.MONTH) {
          Scroll() {
            Column() {
              // æ—¥å†è§†å›¾
              Column() {
                this.buildMonthView()
              }
              .margin({ bottom: 12 })
              
              // è¯¦æƒ…åŒºåŸŸ
              if (this.showDetail) {
                this.buildDetailSection()
              } else {
                Column() {
                  Text('ç‚¹å‡»æ—¥æœŸæŸ¥çœ‹è¯¦æƒ…')
                    .fontSize(14)
                    .fontColor(Constants.COLOR_TEXT_SECONDARY)
                }
                .width('100%')
                .height(200)
                .justifyContent(FlexAlign.Center)
              }
            }
            .width('100%')
          }
          .layoutWeight(1)
          .scrollBar(BarState.Off)
          .edgeEffect(EdgeEffect.Spring)
        } else if (this.currentView === CalendarViewType.WEEK) {
          WeekView({
            selectedDate: $selectedDate,
            events: this.events,
            onEventTap: (event: CalendarEvent) => this.editEvent(event),
            onDateSelect: (date: Date) => {
              this.selectedDate = date;
            }
          })
        } else if (this.currentView === CalendarViewType.DAY) {
          DayView({
            selectedDate: $selectedDate,
            events: this.events,
            calendarInfo: this.selectedCalendarInfo,
            onEventTap: (event: CalendarEvent) => this.editEvent(event)
          })
        }
      }
      .width('100%')
      .height('100%')
      .backgroundColor(Constants.COLOR_BACKGROUND)

      // èœå•å¼¹å‡ºå±‚
      if (this.showMenu) {
        Column()
          .width('100%')
          .height('100%')
          .backgroundColor('rgba(0,0,0,0.3)')
          .onClick(() => {
            this.showMenu = false;
          })
        
        Column() {
          CalendarMenu({
            isShow: $showMenu,
            onJumpToDate: () => {
              this.showJumpDate = true;
            },
            onSearch: () => {
              this.showSearch = true;
            },
            onSettings: () => {},
            onHelp: () => {}
          })
        }
        .position({ x: '50%', y: 100 })
      }

      // æ·»åŠ æ—¥ç¨‹æ‚¬æµ®æŒ‰é’®
      Button('+')
        .type(ButtonType.Circle)
        .width(60)
        .height(60)
        .fontSize(36)
        .fontWeight(FontWeight.Medium)
        .fontColor('#FFFFFF')
        .backgroundColor(Constants.COLOR_PRIMARY)
        .shadow({
          radius: 12,
          color: 'rgba(255, 107, 53, 0.4)',
          offsetX: 0,
          offsetY: 4
        })
        .position({ x: '100%', y: '100%' })
        .translate({ x: -76, y: -76 })
        .zIndex(10)
        .onClick(() => {
          this.createEvent();
        })

      // æ—¥ç¨‹ç¼–è¾‘å¼¹çª—
      if (this.showEventSheet) {
        Column() {
          // åŠé€æ˜é®ç½©
          Column()
            .width('100%')
            .height('100%')
            .backgroundColor('#000000')
            .opacity(0.5)
            .onClick(() => {
              this.showEventSheet = false;
            })
        }
        .width('100%')
        .height('100%')
        .position({ x: 0, y: 0 })
        .zIndex(100)

        Column() {
          EventSheet({
            isShow: $showEventSheet,
            editEvent: this.editingEvent,
            selectedDate: $selectedDate,
            onSave: (event: CalendarEvent) => this.saveEvent(event),
            onDelete: (event: CalendarEvent) => this.deleteEvent(event)
          })
        }
        .width('100%')
        .height('90%')
        .backgroundColor(Constants.COLOR_BACKGROUND)
        .borderRadius({ topLeft: 20, topRight: 20 })
        .position({ x: 0, y: '10%' })
        .zIndex(101)
      }
    }
    .width('100%')
    .height('100%')
  }
}
